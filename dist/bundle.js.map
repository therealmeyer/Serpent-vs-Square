{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/block.js","webpack:///./lib/circle.js","webpack:///./lib/game.js","webpack:///./lib/game_view.js","webpack:///./lib/line.js","webpack:///./lib/moving_object.js","webpack:///./lib/score.js","webpack:///./lib/serp-v-square.js","webpack:///./lib/serpent.js","webpack:///./lib/serpent_node.js","webpack:///./lib/util.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,G;;AAEA;;AAEA,uB;;;;;;;;;;;AC5CA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,wB;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,8BAA8B;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;;AAIA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,2BAA2B,WAAW;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,cAAc;AACjC;;AAEA,yBAAyB,iCAAiC;AAC1D;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sB;;;;;;;;;;;AC7LA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB,EAAE;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,K;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;AAKA,0B;;;;;;;;;;;ACnGA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sB;;;;;;;;;;;ACxBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,8B;;;;;;;;;;;AChFA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uB;;;;;;;;;;;ACtBA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO,O;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH,CAAC;;;;;;;;;;;;;;ACnCD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,0CAA0C,wCAAwC;AAClF;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0B;AACA,QAAQ;AACR;AACA,Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA,kCAAkC,+BAA+B;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yB;;;;;;;;;;;AClIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,eAAe;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,6B;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sB","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/serp-v-square.js\");\n","const MovingObject = require(\"./moving_object\");\nconst Util = require(\"./util\");\n\nclass Block extends MovingObject {\n  constructor(options = {}) {\n    options.color = 'green';\n    // options.pos = [10,5];\n    options.radius = 38;\n    options.vel = [0, 1];\n    super(options);\n    this.value = options.val;\n    this.color = this.getColor(this.value);\n  }\n\n  getColor(value) {\n    if (value === 1) {\n      return '#69F0AE';\n    } else if (value <= 4) {\n      return '#00E676';\n    } else if (value <= 8) {\n      return '#00C853';\n    } else if (value <= 12) {\n      return '#FFD54F';\n    } else if (value <= 16) {\n      return '#FFCA28';\n    } else if (value <= 20) {\n      return '#FF8F00';\n    } else if (value >= 21) {\n      return '#D84315';\n    }\n  }\n\n  draw(ctx) {\n    Util.drawBlock(ctx, this.pos[0], this.pos[1], 77, this.color);\n    if (this.value > 9) {\n      Util.drawText(ctx, this.pos[0]-23, this.pos[1]+20, 50, 'black', this.value);\n    } else {\n      Util.drawText(ctx, this.pos[0]-13, this.pos[1]+20, 50, 'black', this.value);\n    }\n\n  } \n\n}\n\nmodule.exports = Block;","const Util = require(\"./util\");\nconst MovingObject = require(\"./moving_object\");\n\nclass Circle extends MovingObject {\n  constructor(options = {}) {\n    options.color = 'yellow';\n    options.pos = options.pos; //|| options.game.randomPos();\n    options.radius = 10;\n    options.vel = [0, 1];\n    super(options);\n    this.value = this.randomValue();\n  }\n\n  randomValue() {\n    return Math.floor(Math.random() * 6) + 1;\n  }\n\n  draw(ctx) {\n    Util.drawText(ctx, this.pos[0], this.pos[1]-15, 12, this.color, this.value);\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n    ctx.arc(this.pos[0], this.pos[1], this.radius, 0, Math.PI * 2, true);\n    ctx.fill();\n    \n    // Util.drawCircle(ctx, this.pos[0], this.pos[1], this.radius, this.color);\n\n  }\n\n}\n\nmodule.exports = Circle;","const Line = require(\"./line\");\nconst Score = require(\"./score\");\nconst Serpent = require(\"./serpent\");\nconst Block = require(\"./block\");\nconst Circle = require(\"./circle\");\nconst Util = require(\"./util\");\n\nclass Game {\n  constructor() {\n    this.circles = [];\n    this.blocks = [];\n    this.serpents = [];\n    this.lines = [];\n    this.score = 0;\n    \n    this.addBlocks();\n    this.addCircles();\n    this.addLines();\n    this.addBlocks = this.addBlocks.bind(this);\n    this.addCircles = this.addCircles.bind(this);\n    this.addLines = this.addLines.bind(this);\n    setInterval(this.addBlocks, 4500);\n    setInterval(this.addCircles, 4500);\n    setInterval(this.addLines, 4500);\n  }\n\n  addSerpent() {\n    const serpent = new Serpent({ pos: [200, 625], game: this });\n    this.add(serpent);\n    this.serpent = serpent;\n    return serpent;\n  }\n\n  addBlocks() {\n    // debugger;\n    const margin = 3;\n    const blockSize = 78;\n    const serpLength = this.serpent ? this.serpent.length : 5;\n    for (let i = 0; i < 5; i++) {\n      const randVal = Math.floor((Math.random() * serpLength+2) + 1);\n      let x;\n      if (i === 0 ) {\n        x = margin + 40;\n      } else {\n        x = margin + (blockSize * i) + 40;\n      }\n      this.add(new Block({\n        game: this,\n        pos: [x, -1],\n        val: randVal\n      }));\n    }\n\n\n\n    // const margin = 3;\n    // const blockSize = 98;\n    // const serpLength = this.serpent ? this.serpent.length : 5;\n    // for (let i = 0; i < 4; i++) {\n    //   const randVal = Math.floor((Math.random() * serpLength+3) + 1);\n    //   let x;\n    //   if (i === 0 ) {\n    //     x = margin + 50;\n    //   } else {\n    //     x = margin + (blockSize * i) + 50;\n    //   }\n    //   this.add(new Block({\n    //     game: this,\n    //     pos: [x, -1],\n    //     val: randVal\n    //   }));\n    // }\n  }\n\n  addCircles() {\n    const possibleCircs = [40, 90, 140, 170, 185, \n      210, 250, 280, 310, 340, 370];\n    const possY = [100, 150, 180, 200];\n    const randomX = possibleCircs.sort(function () {\n      return 0.5 - Math.random();\n    });\n    const randomY = possY.sort(function () {\n      return 0.5 - Math.random();\n    });\n\n    const numCircles = Math.floor(Math.random() * 3) + 1;\n    for (let i = 0; i < numCircles; i++) {\n      // const posX = possibleCircs[Math.floor(Math.random() * possibleCircs.length)];\n      // const posX = Math.floor(Math.random() * 250) + 100;\n      this.add(new Circle({\n        game: this,\n        pos: [randomX[i], randomY[i]]\n      }));\n    }\n  }\n\n  // addScore() {\n  //   this.add(new Score({game: this}));\n  // }\n\n  addLines() {\n    // const lines = [];\n    // const posY = [42, ]\n    const possibleLines = [82, 161, 240, 320];\n    const random = possibleLines.sort(function () {\n      return 0.5 - Math.random();\n    });\n    const numLines = Math.floor(Math.random() * 4);\n    for (let i = 0; i < numLines; i++) {\n      // const placeX = possibleLines[Math.floor(Math.random() * possibleLines.length)];\n      \n      this.add(new Line({game: this, pos: [random[i], 42]}));\n    }\n\n  }\n\n  add(object) {\n    if (object instanceof Block) {\n      this.blocks.push(object);\n    } else if (object instanceof Circle) {\n      this.circles.push(object);\n    } else if (object instanceof Serpent) {\n      this.serpents.push(object);\n    } else if (object instanceof Score) {\n      this.serpents.push(object);\n    } else if (object instanceof Line) {\n      this.lines.push(object);\n    }\n  }\n\n  draw(ctx) {\n    ctx.clearRect(0,0, Game.DIM_X, Game.DIM_Y);\n    ctx.fillStyle = Game.BG_COLOR;\n    ctx.fillRect(0, 0, Game.DIM_X, Game.DIM_Y);\n\n    ctx.font = 'normal 25px Montserrat';\n    ctx.fillStyle = 'white';\n    ctx.fillText(this.score, 350, 240);\n\n    this.allObjects().forEach((object) => {\n      object.draw(ctx);\n    });\n  }\n\n  isOutOfBounds(pos) {\n     return (pos[0] < 0) || (pos[1] < 0) ||\n       (pos[0] > Game.DIM_X) || (pos[1] > Game.DIM_Y);\n  }\n\n  moveObjects(delta) {\n    this.allObjects().forEach((object) => {\n      object.move(delta);\n    });\n  }\n\n  remove(object) {\n    if (object instanceof Block) {\n      this.blocks.splice(this.blocks.indexOf(object), 1);\n    } else if (object instanceof Circle) {\n      this.circles.splice(this.circles.indexOf(object), 1);\n    }\n  }\n  step(delta) {\n    this.moveObjects(delta);\n    this.checkCollisions();\n  }\n\n  allObjects() {\n    return [].concat(this.blocks, this.circles, this.serpents, this.lines);\n  }\n\n  checkCollisions() {\n    const allObjects = [].concat(this.blocks, this.circles, this.lines);\n    for (let i = 0; i < allObjects.length; i++) {\n      const obj = allObjects[i];\n      if (this.serpent.isCollidedWith(obj)) {\n        const collision = this.serpent.collideWith(obj);\n        this.score += collision;\n        if (collision) return;\n      }\n    }\n  }\n}\n\nGame.BG_COLOR = \"#000000\";\nGame.DIM_X = 400;\nGame.DIM_Y = 850;\nGame.FPS = 60;\n\nmodule.exports = Game;","const keyCodes = {\n  left: [-3, 0],\n  right: [3, 0]\n};\n\nconst pauseButton = document.getElementById(\"pausebtn\");\n// console.log(pauseButton);\n\nclass GameView {\n  constructor(game, ctx) {\n    this.ctx = ctx;\n    this.game = game;\n    this.serpent = this.game.addSerpent();\n    this.keys = Object.create(null);\n    // window.addEventListener('keydown', this.bindKeyHandlers);\n    this.gameStarted = false;\n    // console.log(pauseButton);\n    this.paused = false;\n    pauseButton.addEventListener('click', this.togglePlay.bind(this));\n\n    window.addEventListener('keyup', this.resetSerp.bind(this));\n    this.resetSerp = this.resetSerp.bind(this);\n    this.togglePlay = this.togglePlay.bind(this);\n  }\n\n  bindKeyHandlers() {\n    // if (!e) return;\n    const serpent = this.serpent;\n    Object.keys(keyCodes).forEach((k) => {\n      const move = keyCodes[k];\n      key(k, () => { serpent.power(move); });\n    });\n    // debugger;\n    // if (keyCodes.hasOwnProperty(e.keyCode)) {\n    //   e.preventDefault();\n    //   serpent.power(keyCodes[e.keyCode]);\n    // }\n\n  }\n\n  togglePlay() {\n    debugger;\n    if (!this.gameStarted) {\n      return;\n    }\n    this.paused = !this.paused;\n    if (!this.paused) {\n      this.animate(this.lastTime-100);\n    }\n  }\n\n  resetSerp() {\n    // debugger;\n    this.serpent.resetVel();\n  }\n\n  restart() {\n\n  }\n\n  start() {\n    this.gameStarted = true;\n    if (!this.paused) {\n      this.bindKeyHandlers();\n      this.lastTime = 0;\n      requestAnimationFrame(this.animate.bind(this));\n    } \n  }\n\n  animate(time) {\n    if (this.serpent.length <= 0) {\n      this.ctx.globalAlpha = 0.6;\n      this.ctx.fillStyle = \"black\";\n      this.ctx.fillRect(0, 0, 400, 850);\n      this.ctx.globalAlpha = 1.0;\n      this.ctx.font = 'normal 35px Montserrat';\n      this.ctx.fillStyle = 'white';\n      this.ctx.fillText('Game Over', 110, 500);\n      this.ctx.font = 'normal 35px Montserrat';\n      this.ctx.fillStyle = 'white';\n      this.ctx.fillText(`Your Score: ${this.game.score}`, 90, 550);\n      // this.ctx.font = 'normal 30px FontAwesome';\n      // this.ctx.fillStyle = 'white';\n      // this.ctx.fillText('\\uf521', 110, 450);\n    }\n    else if (!this.paused) {\n      const timeDelta = time - this.lastTime;\n      this.game.step(timeDelta);\n      this.game.draw(this.ctx);\n      this.lastTime = time;\n\n      requestAnimationFrame(this.animate.bind(this));\n    }\n  }\n}\n\n\n\n\nmodule.exports = GameView;","const Util = require(\"./util\");\nconst MovingObject = require(\"./moving_object\");\n\nclass Line extends MovingObject {\n  constructor(options = {}) {\n    options.color = 'white';\n    options.pos = options.pos;\n    options.vel = [0, 1];\n    super(options);\n    this.length = 90;\n  }\n\n  draw(ctx) {\n    ctx.beginPath();\n    ctx.moveTo(this.pos[0], this.pos[1]);\n    ctx.lineTo(this.pos[0], this.pos[1]+this.length);\n    ctx.lineWidth = 5;\n    ctx.strokeStyle = this.color;\n    ctx.lineCap = 'round';\n    ctx.stroke();\n  }\n\n}\n\nmodule.exports = Line;","const Util = require(\"./util\");\n\nclass MovingObject {\n  constructor(options) {\n    this.pos = options.pos;\n    this.vel = options.vel;\n    this.radius = options.radius;\n    this.color = options.color;\n    this.game = options.game;\n\n  }\n\n  draw(ctx) {\n    ctx.fillStyle = this.color;\n\n    ctx.beginPath();\n    ctx.arc(this.pos[0], this.pos[1], this.radius, 0, 2 * Math.PI, true);\n    ctx.fill();\n  }\n\n  isCollidedWith(otherObject) {\n    // console.log(otherObject.constructor.name);\n    // if (otherObject.constructor.name === 'Block') {\n    //   // debugger;\n    //   let blockWidth = otherObject.pos[0] + 48;\n    //   let blockLength = otherObject.pos[1] + 97;\n    //   if (this.pos[1] + this.radius === blockLength && \n    //     this.pos[0] + this.radius < blockWidth && \n    //     this.pos[0] + this.radius > otherObject.pos[0]) {\n        \n    //     return true;\n    //   }\n    //   else {\n    //     return false;\n    //   }\n    // }\n    if (otherObject.constructor.name === 'Line') {\n      // debugger;\n      if (((this.pos[0] + this.radius < otherObject.pos[0] +2\n        && this.pos[0] + this.radius > otherObject.pos[0] -1)\n        || \n        (this.pos[0] - this.radius < otherObject.pos[0] +2 &&\n        this.pos[0] - this.radius > otherObject.pos[0] -1))\n        && \n        (this.pos[1] > otherObject.pos[1] && \n        this.pos[1] < otherObject.pos[1] + otherObject.length + 20)) {\n          // debugger;\n        return true;\n      } else {\n        return false;\n      }\n    }\n    const centerDist = Util.dist(this.pos, otherObject.pos);\n    return centerDist < (this.radius + otherObject.radius);\n  }\n\n  move(timeDelta) {\n    // timeDelta is number of milliseconds since last move\n    // if the computer is busy the time delta will be larger\n    // in this case the MovingObject should move farther in this frame\n    // velocity of object is how far it should move in 1/60th of a second\n    const velocityScale = timeDelta / NORMAL_FRAME_TIME_DELTA,\n      offsetX = this.vel[0] * velocityScale,\n      offsetY = this.vel[1] * velocityScale;\n\n    this.pos = [this.pos[0] + offsetX, this.pos[1] + offsetY];\n\n    if (this.game.isOutOfBounds(this.pos)) {\n      this.remove();\n    }\n  }\n\n  remove() {\n    this.game.remove(this);\n  }\n\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n\nmodule.exports = MovingObject;","const Util = require(\"./util\");\nconst MovingObject = require(\"./moving_object\");\n\nclass Score extends MovingObject {\n  constructor(options = {}) {\n    options.vel = [0,0]\n    options.pos = [370, 10]\n    super(options);\n    this.score = 0;\n    // debugger;\n  }\n\n  increment(num) {\n    this.score += num;\n  }\n\n  draw(ctx) {\n    // debugger;\n    Util.drawText(ctx, 370, 10, 'white', this.score);\n  }\n}\n\nmodule.exports = Score;","const Game = require(\"./game\");\nconst GameView = require(\"./game_view\");\nconst Util = require(\"./util\");\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvasEl = document.getElementById(\"game-canvas\");\n  canvasEl.width = 400;\n  canvasEl.height = 850;\n\n  const ctx = canvasEl.getContext(\"2d\");\n  ctx.imageSmoothingEnabled = true;\n  ctx.clearRect(0,0, 400, 850);\n  ctx.fillStye = \"black\";\n  ctx.fillRect(0,0, 400, 850);\n  ctx.font = 'normal 35px Montserrat';\n  ctx.fillStyle = 'white';\n  ctx.fillText(\"Click to Start\", 100, 400);\n  Util.drawText(ctx, 200, 625- 15, 12, 'yellow', 4);\n  for (let i=0; i < 4; i++) { \n    ctx.fillStyle = 'yellow';\n    ctx.beginPath();\n    ctx.arc(200, 625 + (i * 22), 10, 0, Math.PI * 2, true);\n    ctx.fill();\n  }\n\n  document.getElementById(\"restart\").addEventListener('click', () => {\n    const game = new Game();\n    new GameView(game, ctx).start();\n  });\n    \n  document.getElementById(\"game-canvas\").addEventListener('click', () => {\n    const game = new Game();\n    new GameView(game, ctx).start();\n  });\n\n});\n\n\n","const MovingObject = require(\"./moving_object\");\nconst Util = require(\"./util\");\nconst Circle = require(\"./circle\");\nconst Block = require(\"./block\");\nconst SerpentNode = require(\"./serpent_node\");\nconst Line = require(\"./line\");\n\nclass Serpent extends MovingObject {\n  constructor(options) {\n    options.radius = 10;\n    options.vel = [0,0];\n    options.color = 'yellow';\n    // options.pos = [5,5];\n    super(options);\n    this.prevX = [];\n    this.length = 4;\n    this.leftColliding = false;\n    this.rightColliding = false;\n    // this.nodes = [];\n    // for (let i = 0; i < this.length; i++) {\n    //   this.nodes.push(new SerpentNode({pos: [this.pos[0], this.pos[1]+(i*22)] }))\n    // }\n    this.power = this.power.bind(this);\n  }\n\n  \n\n  addLength(length) {\n    this.length += length;\n  }\n\n  collideWith(otherObject) {\n    // debugger;\n    if (otherObject instanceof Circle) {\n      this.length += otherObject.value;\n      // this.updateLength()\n      otherObject.remove();\n      return 0;\n    } else if (otherObject instanceof Block) {\n      if (otherObject.value < this.length) {\n        for (let i=0; i < otherObject.value; i++) {\n          this.length -= 1;\n        }\n        // this.updateLength(otherObject.value);\n        // this.length -= otherObject.value;\n        otherObject.remove();\n        return otherObject.value;\n      }\n      else {\n        let length = this.length;\n        this.length -= otherObject.value;\n        // this.updateLength(otherObject.value);\n        otherObject.remove();\n        return length;\n        // this.remove();\n      }\n    } else if (otherObject instanceof Line) {\n        // debugger;\n        if (otherObject.pos[0] > this.pos[0]) {\n          this.rightColliding = true;\n          // this.pos[0] = otherObject.pos - this.radius;\n        } else {\n          this.leftColliding = true;\n          // this.pos[0] = otherObject.pos + this.radius;\n        }\n        this.vel = [0,0];\n        return 0;\n    }\n  }\n  power(impulse) {\n    this.vel = [0, 0];\n\n    // if (key === 'left' && this.pos[0] > 1) {\n    //   this.vel[0] += 1; \n    // } else if (key === 'right' && this.pos[0] < 399) {\n    //   this.vel[0] -= 1;\n    // } \n    // debugger;\n    // if (this.pos[0] > 1 && this.pos[0] < 8) {\n    //   debugger;\n    // }\n    if (this.pos[0] < 1 ) {\n        this.pos[0] = 2;\n        return;\n    }\n    if (this.pos[0] > 399) {\n      this.pos[0] = 398;\n      return;\n    }\n\n    if (impulse[0] < 0 && this.pos[0] > 5 && this.pos[0] < 399 && !this.leftColliding) {\n      this.vel[0] += impulse[0];\n    } else if (impulse[0] > 0 && this.pos[0] > 5 && this.pos[0] < 399 && !this.rightColliding) {\n      this.vel[0] += impulse[0];\n    }\n    this.leftColliding = false;\n    this.rightColliding = false;\n    // if (this.pos[0] > 1 && this.pos[0] < 399 && ) {\n    //   this.vel[0] += impulse[0];\n    // }\n    // this.pos[1] += impulse[1];\n  }\n\n  resetVel() {\n    this.vel = [0,0];\n  }\n\n  draw(ctx) {\n    // ctx.fillStyle = this.color;\n    // ctx.fillText(this.length, this.pos[0], this.pos[1]-15)\n    Util.drawText(ctx, this.pos[0], this.pos[1]-15, 12, this.color, this.length);\n    \n    this.prevX.unshift(this.pos[0]);\n    if (this.prevX.length > 1000) {\n      this.prevX.pop();\n    }\n    for(let i = 0; i < this.length; i++) {\n      const prev = this.prevX[i*5] === null ? this.pos[0] : this.prevX[i*5]\n      let node = new SerpentNode({pos: [prev, this.pos[1] + (i)]});\n      // this.nodes[i].changeVelocity(i, this.vel);\n      node.draw(ctx, i, this.vel);\n\n      // ctx.fillStyle = this.color;\n      // ctx.beginPath();\n      // ctx.arc(this.pos[0] + this.vel[0]*(i*(-10)), this.pos[1] + (i*22), this.radius, 0, Math.PI *2, true);\n      // ctx.fill();\n    }\n  }\n}\n\nmodule.exports = Serpent;","const MovingObject = require(\"./moving_object\");\n\nclass SerpentNode extends MovingObject {\n  constructor(options) {\n    options.radius = 10;\n    options.vel = [0,0];\n    options.color = 'yellow';\n    super(options);\n  }\n\n  changeVelocity(i, vel) {\n    setTimeout(() => {this.vel = vel; }\n    , 1000*i);\n  }\n\n  draw(ctx, i) {\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n    ctx.arc(this.pos[0], this.pos[1] + (i*22), this.radius, 0, Math.PI*2, true);\n    ctx.fill();\n  }\n\n}\n\nmodule.exports = SerpentNode;","const Util = {\n  // Normalize the length of the vector to 1, maintaining direction.\n  dir(vec) {\n    const norm = Util.norm(vec);\n    return Util.scale(vec, 1 / norm);\n  },\n  // Find distance between two points.\n  dist(pos1, pos2) {\n    return Math.sqrt(\n      Math.pow(pos1[0] - pos2[0], 2) + Math.pow(pos1[1] - pos2[1], 2)\n    );\n  },\n  // Find the length of the vector.\n  norm(vec) {\n    return Util.dist([0, 0], vec);\n  },\n  // Return a randomly oriented vector with the given length.\n  randomVec(length) {\n    const deg = 2 * Math.PI * Math.random();\n    return Util.scale([Math.sin(deg), Math.cos(deg)], length);\n  },\n  // Scale the length of a vector by the given amount.\n  scale(vec, m) {\n    return [vec[0] * m, vec[1] * m];\n  },\n\n  wrap(coord, max) {\n    if (coord < 0) {\n      return max - (coord % max);\n    } else if (coord > max) {\n      return coord % max;\n    } else {\n      return coord;\n    }\n  },\n\n  drawCircle(ctx, x, y, radius, color) {\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2, true);\n  },\n\n  drawText(ctx, x, y, size, color, text) {\n    ctx.font = `normal ${size}px Montserrat`;\n    ctx.fillStyle = color;\n    ctx.fillText(text, x, y);\n  },\n\n  drawBlock(ctx, x,y, size, color) {\n    const radius = 25;\n    ctx.strokeStyle = color;\n    ctx.lineJoin = \"round\";\n    ctx.lineWidth = radius;\n\n    ctx.strokeRect(\n      x + (radius/2) - size/2,\n      y + (radius/2) - size/2,\n      size - radius,\n      size - radius\n    );\n    ctx.fillStyle = color;\n    ctx.fillRect(\n      x + (radius / 2) -size/2,\n      y + (radius / 2) -size/2,\n      size - radius,\n      size - radius\n    );\n  }\n};\n\nmodule.exports = Util;"],"sourceRoot":""}